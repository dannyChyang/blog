
## 编译过程
常见编译型语言（如Java）的编译过程基本可以分为几步：词法分析 > 语法分析 > 语义检查 > 代码优化和字节码生成

解释型语言（如：javascript）的编译的过程：词法分析 > 语法分析 > 语法树 > 解释执行

> 编译过程就是编译器把程序分解成`词法单元(token)`，然后把词法单元解析成`语法树(AST)`，再把语法树变成`机器指令`等待执行的过程

上面清晰地阐释了javascript语言的编译执行过程，主要分为3个阶段：

### 1. 分词
编程语言要转换为计算机可以理解并执行的前提，就是先将代码字符串分解，赋予其代码块的意义，这些代码块称为`词法单元`。

比如下面的代码
```
var a = 2;
```
代码分解后，形成了一个词法单元数组
```
[
    "var" : "keyword",
    "a" : "identifier",
    "="   : "assignment",
    "2"  : "integer",
    ";"   : "eos" (end of statement)
]
```

    
### 2. 解析
分解后的词法单元，会被转换为一个层级嵌套的树状结构，称为`抽象语法树(Abstract syntax tree)`。

`var a = 1;` 语句在解析后的抽象语法树结构如下：（使用esprima库）
```
{
  "type": "VariableDeclaration",
  "declarations": [
    {
      "type": "VariableDeclarator",
      "id": {
        "type": "Identifier",
        "name": "a"
      },
      "init": {
        "type": "Literal",
        "value": 1,
        "raw": "1"
      }
    }
  ],
  "kind": "var"
}
```
结构中的顶层是一个`VariableDeclaration`节点，表示当前是一个变量声明，在声明集合`declarations`中，第一个子节点是一个`VariableDeclarator`变量声明器，声明了名称为`a`的变量，并赋予值为字面量`1`；

### 3. 生成
经过编译过程之后，AST转换为可执行代码的过程称为代码生成。目的是将AST转换为机器指令并执行，这部分工作由引擎来完成。


### 编译执行的完整示例
```
var a = 2; 
```

1. 编译
    1. 编译器碰到`var a`，首先向作用域发请求，要求查找作用域中是否存在`a`这个变量，有则继续，没有会在作用域中创建一个，初始化其值为 `undefined`；
    2. 编译器只做编译工作，赋值是解释执行时才处理的，`a=2`是赋值语句，编译器不需要处理，因此编译完成，控制权交给引擎执行代码；
2. 执行
    1. 执行时发现是一个赋值表达式，按 `=操作符` 拆分为左右两部分，先向作用域询请求查找`a`的声明；
    2. 将`a`赋值为`2`；
    3. 执行完毕；

在上面的步骤中，首先是从作用域中查找变量，涉及到`作用域`的概念与`变量查找`的知识点，

## 作用域
在编程语言中，作用域可以分为`词法作用域`与`动态作用域`
，javascript作为一门动态解释型语言，使用`词法作用域`，也叫`静态作用域`。

简单来说，**词法作用域是由写代码时，代码所在的位置来决定作用范围的。**

在ES6之前，只有`函数作用域`及`全局作用域`两种。

先看一段代码：

```
var a = 1;
function fn() {
  console.log('1:' + a);

  var a = 2;
  bar()
  console.log('2:' + a)
}

function bar() {
  console.log('3:' + a)
}

fn()

// 运行结果:
=> 1:undefined
   3:1
   2:2
```
上面的结果输出`1:undefined 3:1 2:2`，当执行函数 fn 时，fn作用域内的 `var a` 首先被提升，此时`a=undefined`，接着赋值为2；当调用函数bar时，bar作用域内找不到a的声明，开始向上查找。
**`此时请注意：`** 如果是动态作用域，会依调用顺序向上查找，在fn中调用了bar，那么fn的作用域就是bar作用域的上级，找到a=2；而如果是静态作用域，则以**函数定义时的位置来定义层级关系**，全局作用域是bar作用域的上级，因此向上查找得到a=1；

##### 函数作用域的预编译
函数拥有自己的作用域，这里需要注意一下函数在被调用时的预编译阶段，声明提升的先后顺序
```
function f(a){
    console.log(a);
    var a = 3;
    console.log(a);
}
f(2);
```
1. 在调用f函数时，形参a首先被提升,声明a并赋值undefined;
2. 函数体内变量a开始提升，但是在查找声明过程中，发现作用域内已经有a的声明了，因此该声明被忽略；
3. 实参的值2被赋予形参a；

上面的结果输出`2 3`，说明在函数作用域内，虽然存在声明提升，但是实参赋值动作也发生在预编译阶段。

## LHS查询与RHS查询
在一次赋值操作时，需要分别对左侧的变量声明与右侧的值进行查询，`对左侧声明的查询叫做LHS查询`，`对右侧的值的查询称为RHS查询`;

```
function f(a){
    b = a+5;
    console.log(b);
}
f(2);
```
上面代码段中，查询顺序如下：
1. 代码执行，发现函数调用，对f进行RHS查询，取得f函数；
2. 调用f函数时传入实参2，这里存在一个隐式的、实参到形参的赋值动作`a=2`；所以对形参a进行LHS查询，其定义在f的函数作用域内，2是原始值，不需要RHS查询；
3. 执行`b=a+5`，进行b的LHS，作用域链中未找到b的声明，因此会在全局作用域中声明一个b；赋值等号右侧是一个计算表达式，对a进行RHS查询取到值2；计算之后`b=5`；
4. 执行`console.log()`，对console进行RHS查询，取得console的值之后，接着进行`console.log`的RHS查询；
5. 调用log()函数时，对传入参数b进行RHS查询；


## LHS与RHS的异常处理
我们对代码进行一下调整
```
function f(a){
    console.log(2);
    b = a+c;
    console.log(b);
}
f(2);
```
修改b的赋值表达式右侧，使用了未声明过的`变量c`，执行时会报 `ReferenceError`引用错误，这是因为对c进行的是RHS查询，这里引申出LHS与RHS的区别：

**LHS查询时，当作用域链中找不到声明时，会隐式得自动在`全局作用域`中声明一个，而RHS查询时则不会有该动作。** 

上面的执行结果，会先输出 `2` ，再报错，由此说明**自动声明动作是在LHS查询过程中完成的，而不是编译时完成的。**

> Tips：只有**非严格模式**下，LHS才会自动在全局作用域中声明，并且该动作是在LHS过程中发生的。

## 小结
- 编译过程就是编译器把程序分解成 `词法单元(token)` ，然后把词法单元解析成 `语法树(AST)` ，再把语法树变成 `机器指令` 等待执行的过程；
- javascript使用 `词法作用域` ，简单来说，即作用范围是由书写代码所在位置的结构来决定的；
- 查询分为LHS及RHS查询，即分别对声明的查询和对值的查询；LHS查询时有隐式声明的动作；
